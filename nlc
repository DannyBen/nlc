#!/usr/bin/env bash
# This script was generated by bashly 1.3.6 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script
# :command.root_command
root_command() {
  # src/root_command.sh
  # Build request text
  local message="${args[message]}"
  local cmd

  printf "\n%s ..." "$(blue '$')"
  cmd="$(process_request "$message")"
  execute_command "$cmd"

}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
nlc_usage() {
  printf "nlc - Natural Language â†’ Command\n\n"

  printf "%s\n" "Usage:"
  printf "  nlc MESSAGE...\n"
  printf "  nlc --help | -h\n"
  printf "  nlc --version | -v\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MESSAGE..."
    printf "    Natural language description of the command you want to run\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "NLC_PROVIDER"
    printf "    The provider to use (openai or groq)\n"
    printf "    %s\n" "Allowed: openai, groq"
    printf "    %s\n" "Default: openai"
    echo

    # :environment_variable.usage
    printf "  %s\n" "OPENAI_API_KEY"
    printf "    Your OpenAI API key\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "GROQ_API_KEY"
    printf "    Your Groq API key\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "NLC_MODEL"
    printf "    The model to use (default depending on provider)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  nlc convert input.webm to output.mp4 using the best standards and ffmpeg\n"
    printf "  nlc list all docker images older than a month and delete them\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  local k

  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/build_payload.sh
build_payload() {
  local message="$1"

  jq -n \
    --arg model "$model" \
    --arg system "$system_prompt" \
    --arg user "$message" \
    '{
      model: $model,
      messages: [
        {role: "system", content: $system},
        {role: "user", content: $user}
      ],
      temperature: 0,
      max_tokens: 512
    }'
}

# src/lib/colors.sh
enable_auto_colors() {
  if [[ -z ${NO_COLOR+x} && ! -t 1 ]]; then
    NO_COLOR=1
  fi
}

print_in_color() {
  local color="$1"
  shift
  if [[ "${NO_COLOR:-}" == "" ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
black() { print_in_color "\e[30m" "$*"; }
white() { print_in_color "\e[37m" "$*"; }

bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }

red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
black_bold() { print_in_color "\e[1;30m" "$*"; }
white_bold() { print_in_color "\e[1;37m" "$*"; }

red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }
black_underlined() { print_in_color "\e[4;30m" "$*"; }
white_underlined() { print_in_color "\e[4;37m" "$*"; }

# src/lib/execute_command.sh
execute_command() {
  local cmd="$1"
  if [[ -z "$cmd" ]]; then
    printf "\rError: Model returned empty output" >&2
    exit 2
  fi

  printf "\r%s %s " "$(blue '$')" "$(green_bold "$cmd")"

  local choice=""
  if ! IFS= read -r choice; then
    echo ""
  fi

  echo ""

  if [[ -z "$choice" ]]; then
    /bin/bash -lc "$cmd"
    exit $?
  else
    echo "Cancelled."
    exit 0
  fi
}

# src/lib/filter_api_key_found.sh
filter_api_key_found() {
  local openai_key="${OPENAI_API_KEY:-}"
  local groq_key="${GROQ_API_KEY:-}"

  if [[ "$provider" == "openai" && -z "$openai_key" ]]; then
    echo "OPENAI_API_KEY not set"
  elif [[ "$provider" == "groq" && -z "$groq_key" ]]; then
    echo "GROQ_API_KEY not set"
  fi
}

# src/lib/process_request.sh
process_request() {
  local user_request="$1"
  local auth_header
  local payload
  local response
  local content

  auth_header="Authorization: Bearer $api_key"
  payload="$(build_payload "$user_request")"

  response="$(curl -sS "$api_base/chat/completions" \
    -H "Content-Type: application/json" \
    -H "$auth_header" \
    -d "$payload")" || {
      printf "\rError contacting ${provider}" >&2
      exit 2
    }

  if jq -e '.error' >/dev/null 2>&1 <<<"$response"; then
    local err
    err="$(jq -r '.error.message // "Unknown error"' <<<"$response")"
    printf "\rError contacting ${provider}: ${err}" >&2
    exit 2
  fi

  content="$(jq -r '.choices[0].message.content // ""' <<<"$response")"
  strip_code_fences "$content"
}

# src/lib/strip_code_fences.sh
strip_code_fences() {
  local s="$1"
  s="$(printf '%s' "$s" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
  if [[ "$s" == '```'* ]]; then
    s="$(printf '%s\n' "$s" | sed '1{/^```/d;}; ${/^```/d;}')"
  fi
  s="$(printf '%s' "$s" | sed -e 's/^`*//' -e 's/`*$//')"
  printf '%s' "$s"
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        nlc_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export NLC_PROVIDER="${NLC_PROVIDER:-openai}"

  env_var_names+=("NLC_PROVIDER")
  env_var_names+=("OPENAI_API_KEY")
  env_var_names+=("GROQ_API_KEY")
  env_var_names+=("NLC_MODEL")
  if [[ -n "${NLC_PROVIDER:-}" ]] && [[ ! ${NLC_PROVIDER:-} =~ ^(openai|groq)$ ]]; then
    printf "%s\n" "NLC_PROVIDER environment variable must be one of: openai, groq" >&2
    exit 1
  fi

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v curl >/dev/null 2>&1; then
    printf "missing dependency: curl\n" >&2
    missing_deps=1
  else
    deps['curl']="$(command -v curl | head -n1)"
  fi

  # :dependency.filter
  if ! command -v jq >/dev/null 2>&1; then
    printf "missing dependency: jq\n" >&2
    missing_deps=1
  else
    deps['jq']="$(command -v jq | head -n1)"
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action="root"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_repeatable
        # :argument.case_repeatable
        escaped="$(printf '%q' "$1")"
        if [[ -z ${args['message']+x} ]]; then
          args['message']="$escaped"
        else
          args['message']="${args['message']} $escaped"

        fi
        shift

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['message']+x} ]]; then
    printf "missing required argument: MESSAGE\nusage: nlc MESSAGE...\n" >&2

    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_api_key_found)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.initialize
initialize() {
  declare -g version="0.2.0"
  set -e

  # :command.environment_variables_default
  export NLC_PROVIDER="${NLC_PROVIDER:-openai}"

  # :command.variables
  # :variable.definition
  declare -g api_base=""

  # :variable.definition
  declare -g api_key=""

  # :variable.definition
  declare -g model="$NLC_MODEL"

  # :variable.definition
  declare -g provider="$NLC_PROVIDER"

  # :variable.definition
  declare -g system_prompt="You are a command-line generator.
  Return ONLY an executable bash command or sequence of commands.
  NO backticks. NO explanations. NO comments.
  Prefer widely-available tools.
  Prefer short commands, do NOT overengineer.
  Default to safe, non-destructive options unless explicitly requested otherwise.
  Quote/escape filenames or arguments when necessary.
  If the request is ambiguous, choose sensible defaults rather than asking questions.
  Output must be valid for /bin/bash -lc (newlines, pipes, redirection are fine).
  "

  # src/initialize.sh
  case "$provider" in
    openai)
      api_base="https://api.openai.com/v1"
      api_key="$OPENAI_API_KEY"
      model="${model:-gpt-4.1-mini}"
      ;;
    groq)
      api_base="https://api.groq.com/openai/v1"
      api_key="$GROQ_API_KEY"
      model="${model:-llama-3.3-70b-versatile}"
      ;;
  esac

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root") root_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
