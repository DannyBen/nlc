#!/usr/bin/env bash
# This script was generated by bashly 1.3.6 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
nlc_usage() {
  printf "nlc - Natural Language â†’ Command\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  nlc COMMAND\n"
  printf "  nlc [COMMAND] --help | -h\n"
  printf "  nlc --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Run a natural language command (default)\n" "$(green "run")          "
  printf "  %s   Manage configuration\n" "$(green "config")       "
  printf "  %s   Show confiruation and environment\n" "$(green "config show")  "
  printf "  %s   Delete the config file (falling back to default values)\n" "$(green "config clear") "
  printf "  %s   Edit the confiruation file (create it first if needed)\n" "$(green "config edit")  "
  printf "  %s   Create a new config file\n" "$(green "config new")   "
  printf "  %s   Manage system prompt\n" "$(green "prompt")       "
  printf "  %s   Show or edit system prompt\n" "$(green "prompt system")"
  printf "  %s   Show or edit user prompt\n" "$(green "prompt user")  "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "$(green "--version, -v")"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "$(bold "Environment Variables:")"

    # :environment_variable.usage
    printf "  %s\n" "$(green "NLC_CONFIG")"
    printf "    Path to the NLC config file\n"
    printf "    %s\n" "Default: ~/.nlc/config"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  nlc convert input.webm to output.mp4\n"
    printf "  nlc list all docker images older than a month and delete them\n"
    echo

  fi
}

# :command.usage
nlc_run_usage() {
  printf "nlc run - Run a natural language command\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  nlc [run] MESSAGE...\n"
  printf "  nlc run --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "MESSAGE...")"
    printf "    Natural language description of the command you want to run\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  nlc convert input.webm to output.mp4\n"
    printf "  nlc list all docker images older than a month and delete them\n"
    echo

  fi
}

# :command.usage
nlc_config_usage() {
  printf "nlc config - Manage configuration\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  nlc config COMMAND\n"
  printf "  nlc config [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Show confiruation and environment\n" "$(green "show") "
  printf "  %s   Delete the config file (falling back to default values)\n" "$(green "clear")"
  printf "  %s   Edit the confiruation file (create it first if needed)\n" "$(green "edit") "
  printf "  %s   Create a new config file\n" "$(green "new")  "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
nlc_config_show_usage() {
  printf "nlc config show - Show confiruation and environment\n\n"
  printf "Alias: s\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nlc config show\n"
  printf "  nlc config show --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
nlc_config_clear_usage() {
  printf "nlc config clear - Delete the config file (falling back to default values)\n\n"
  printf "Alias: c\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nlc config clear\n"
  printf "  nlc config clear --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
nlc_config_edit_usage() {
  printf "nlc config edit - Edit the confiruation file (create it first if needed)\n\n"
  printf "Alias: e\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nlc config edit\n"
  printf "  nlc config edit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
nlc_config_new_usage() {
  printf "nlc config new - Create a new config file\n\n"
  printf "Alias: n\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nlc config new [OPTIONS]\n"
  printf "  nlc config new --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--force, -f")"
    printf "    Overwrite file if it exists\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
nlc_prompt_usage() {
  printf "nlc prompt - Manage system prompt\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  nlc prompt COMMAND\n"
  printf "  nlc prompt [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Show or edit system prompt\n" "$(green "system")"
  printf "  %s   Show or edit user prompt\n" "$(green "user")  "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
nlc_prompt_system_usage() {
  printf "nlc prompt system - Show or edit system prompt\n\n"
  printf "Alias: s\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nlc prompt system [OPTIONS]\n"
  printf "  nlc prompt system --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--edit, -e")"
    printf "    Open the file for editing\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(green "--default, -d")"
    printf "    Copy the default system prompt to the override file\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(green "--clear, -c")"
    printf "    Delete the prompt override file\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  # clone the default config and open for editing\"\n  nlc prompt system -ed\n"
    echo

  fi
}

# :command.usage
nlc_prompt_user_usage() {
  printf "nlc prompt user - Show or edit user prompt\n\n"
  printf "Alias: u\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nlc prompt user [OPTIONS]\n"
  printf "  nlc prompt user --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--edit, -e")"
    printf "    Open the file for editing\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(green "--clear, -c")"
    printf "    Delete the prompt override file\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  local k

  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/build_payload.sh
build_payload() {
  local message="$1"
  local system_prompt

  system_prompt="$(prompt_full)"

  jq -n \
    --arg model "$MODEL" \
    --arg system "$system_prompt" \
    --arg user "$message" \
    '{
      model: $model,
      messages: [
        {role: "system", content: $system},
        {role: "user", content: $user}
      ],
      temperature: 0,
      max_tokens: 512
    }'
}

# src/lib/config/config.sh
config_show() {
  config_load
  ini_show
}

config_get() {
  local key="${1-}"
  local default_value="${2-}"

  config_load
  echo "${ini["$key"]:-$default_value}"
}

config_set() {
  local key="${1-}"
  shift
  local value="$*"

  config_load
  ini["$key"]="$value"
  config_save
}

config_del() {
  local key="${1-}"

  config_load
  unset "ini[$key]"
  config_save
}

config_keys() {
  config_load
  ini_keys
}

config_has_key() {
  [[ $(config_get "$1") ]]
}

config_reload() {
  declare -g config_loaded=false
  config_load
}

config_load() {
  [[ "${config_loaded-}" == "true" ]] && return

  declare -g CONFIG_FILE=${CONFIG_FILE:=config.ini}
  declare -g config_loaded=true
  [[ -f "$CONFIG_FILE" ]] || touch "$CONFIG_FILE"
  ini_load "$CONFIG_FILE"
}

config_save() {
  ini_save "$CONFIG_FILE"
}

# src/lib/config/create_defaults.sh
config_create_defaults() {
  config_dir="$(dirname -- "$CONFIG_FILE")"
  mkdir -p -- "$config_dir"

  config_set ai.provider openai
  config_set ai.model gpt-3.5-turbo
  config_set ai.api_key
  config_set ai.api_base https://api.openai.com/v1
  config_set prompt.system "$HOME/.nlc/system_prompt"
  config_set prompt.user "$HOME/.nlc/user_prompt"
  config_save
}

# src/lib/config/ini.sh
ini_load() {
  unset ini
  declare -gA ini

  local ini_file="$1"

  local section=""
  local key=""
  local value=""
  local section_regex="^\[(.+)\]"
  local key_regex="^([^ =]+) *= *(.*) *$"
  local comment_regex="^;"

  while IFS= read -r line; do
    if [[ $line =~ $comment_regex ]]; then
      continue
    elif [[ $line =~ $section_regex ]]; then
      section="${BASH_REMATCH[1]}."
    elif [[ $line =~ $key_regex ]]; then
      key="${BASH_REMATCH[1]}"
      value="${BASH_REMATCH[2]}"
      [[ $value == *\$* ]] && eval "value=\"$value\""
      ini["${section}${key}"]="$value"
    fi
  done <"$ini_file"
}

ini_save() {
  declare -gA ini

  local ini_file="$1"

  local current_section=""
  local has_free_keys=false

  rm -f "$ini_file"

  for key in $(ini_keys); do
    [[ $key == *.* ]] && continue
    has_free_keys=true
    value="${ini[$key]}"
    echo "$key = $value" >>"$ini_file"
  done

  [[ "${has_free_keys}" == "true" ]] && echo >>"$ini_file"

  for key in $(ini_keys); do
    [[ $key == *.* ]] || continue
    value="${ini[$key]}"
    IFS="." read -r section_name key_name <<<"$key"

    if [[ "$current_section" != "$section_name" ]]; then
      [[ $current_section ]] && echo >>"$ini_file"
      echo "[$section_name]" >>"$ini_file"
      current_section="$section_name"
    fi

    echo "$key_name = $value" >>"$ini_file"
  done
}

ini_show() {
  declare -gA ini

  for key in $(ini_keys); do
    echo "$key = ${ini[$key]}"
  done
}

ini_keys() {
  declare -gA ini

  local keys=("${!ini[@]}")
  for a in "${keys[@]}"; do echo "$a"; done | sort
}

# src/lib/execute_command.sh
execute_command() {
  local cmd="$1"
  if [[ -z "$cmd" ]]; then
    printf "\rerror: model returned empty output" >&2
    exit 2
  fi

  printf "\r%s %s " "$(blue '$')" "$(green_bold "$cmd")"

  local choice=""
  if ! IFS= read -r choice; then
    echo ""
  fi

  echo ""

  if [[ -z "$choice" ]]; then
    /bin/bash -lc "$cmd"
    exit $?
  else
    echo "Cancelled."
    exit 0
  fi
}

# src/lib/filter/api_key_found.sh
filter_api_key_found() {
  if [[ "$PROVIDER" == "openai" && -z "$OPENAI_API_KEY" ]]; then
    echo "OPENAI_API_KEY not set"
  elif [[ "$PROVIDER" == "groq" && -z "$GROQ_API_KEY" ]]; then
    echo "GROQ_API_KEY not set"
  fi
}

# src/lib/process_request.sh
process_request() {
  local user_request="$1"
  local auth_header
  local payload
  local response
  local content

  auth_header="Authorization: Bearer $API_KEY"
  payload="$(build_payload "$user_request")"

  response="$(curl -sS "$API_BASE/chat/completions" \
    -H "Content-Type: application/json" \
    -H "$auth_header" \
    -d "$payload" 2>&1)" || {
    printf "\rcurl error: %s\n" "$response" >&2
    exit 2
  }

  if jq -e '.error' >/dev/null 2>&1 <<<"$response"; then
    local err
    err="$(jq -r '.error.message // "Unknown error"' <<<"$response" 2>&1)"
    printf "\rapi error: %s\n" "${err}" >&2
    exit 2
  fi

  content="$(jq -r '.choices[0].message.content // ""' <<<"$response")"
  strip_code_fences "$content"
}

# src/lib/prompt/default.sh
prompt_default() {
  echo "You are a command-line generator."
  echo "Return ONLY an executable bash command or sequence of commands."
  echo "NO backticks. NO explanations. NO comments."
  echo "Prefer widely-available tools."
  echo "Prefer common, user-facing commands over specialized or terse variants."
  echo "Prefer short commands, do NOT overengineer."
  echo "Default to safe, non-destructive options unless explicitly requested otherwise."
  echo "Quote/escape filenames or arguments when necessary."
  echo "Assume all operations are to be executed in the current directory unless requested otherwise"
  echo "If the request is ambiguous, choose sensible defaults rather than asking questions."
  echo "Output must be valid for /bin/bash -lc (newlines, pipes, redirection are fine)."
  echo "OS Distro: $(distro)"
}

# src/lib/prompt/full.sh
prompt_full() {
  prompt_system
  echo "---"
  prompt_user
}

# src/lib/prompt/system.sh
prompt_system() {
  if [[ -s "$SYSTEM_PROMPT_FILE" ]]; then
    cat "$SYSTEM_PROMPT_FILE"
  else
    prompt_default
  fi
}

# src/lib/prompt/user.sh
prompt_user() {
  if [[ -f "$USER_PROMPT_FILE" ]]; then
    cat "$USER_PROMPT_FILE"
  fi
}

# src/lib/util/colors.sh
enable_auto_colors() {
  if [[ -z ${NO_COLOR+x} && ! -t 1 ]]; then
    NO_COLOR=1
  fi
}

print_in_color() {
  local color="$1"
  shift
  if [[ "${NO_COLOR:-}" == "" ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
black() { print_in_color "\e[30m" "$*"; }
white() { print_in_color "\e[37m" "$*"; }

bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
bold_underlined() { print_in_color "\e[1;4m" "$*"; }

red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
black_bold() { print_in_color "\e[1;30m" "$*"; }
white_bold() { print_in_color "\e[1;37m" "$*"; }

red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }
black_underlined() { print_in_color "\e[4;30m" "$*"; }
white_underlined() { print_in_color "\e[4;37m" "$*"; }

# src/lib/util/distro.sh
distro() {
  if [ -r /etc/os-release ]; then
    # shellcheck disable=SC1091
    . /etc/os-release
    echo "${PRETTY_NAME:-${NAME:-${ID:-unknown}}}"
  else
    echo "Unknown"
  fi
}

# src/lib/util/strip_code_fences.sh
strip_code_fences() {
  local s="$1"
  s="$(printf '%s' "$s" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
  if [[ "$s" == '```'* ]]; then
    s="$(printf '%s\n' "$s" | sed '1{/^```/d;}; ${/^```/d;}')"
  fi
  s="$(printf '%s' "$s" | sed -e 's/^`*//' -e 's/`*$//')"
  printf '%s' "$s"
}

# src/lib/util/truncate_mid.sh
truncate_mid() {
  local s="$1"
  local n="${2:-5}"

  s=${s//$'\n'/}
  s=${s//$'\r'/}

  local len=${#s}

  if ((len <= 2 * n)); then
    printf '%s\n' "$s"
    return
  fi

  printf '%s\n' "${s:0:n}...${s:len-n:n}"
}

# :command.command_functions
# :command.function
nlc_run_command() {

  # src/commands/run.sh
  # Build request text
  local message="${args[message]}"
  local cmd

  printf "\n%s ..." "$(blue '$')"
  cmd="$(process_request "$message")"
  execute_command "$cmd"

}

# :command.function
nlc_config_show_command() {

  # src/commands/config/show.sh
  bold_underlined "Environment"
  printf "  %-28s: %s\n" "$(green NLC_CONFIG)" "$NLC_CONFIG"
  printf "  %-28s: %s\n" "$(green OPENAI_API_KEY)" "$(truncate_mid "$OPENAI_API_KEY")"
  printf "  %-28s: %s\n" "$(green GROQ_API_KEY)" "$(truncate_mid "$GROQ_API_KEY")"
  echo

  bold_underlined "Internal Truth"
  printf "  %-28s: %s\n" "$(green CONFIG_FILE)" "$CONFIG_FILE"
  printf "  %-28s: %s\n" "$(green PROVIDER)" "$PROVIDER"
  printf "  %-28s: %s\n" "$(green MODEL)" "$MODEL"
  printf "  %-28s: %s\n" "$(green API_BASE)" "$API_BASE"
  printf "  %-28s: %s\n" "$(green API_KEY)" "$(truncate_mid "$API_KEY")"
  printf "  %-28s: %s\n" "$(green USER_PROMPT_FILE)" "$USER_PROMPT_FILE"
  printf "  %-28s: %s\n" "$(green SYSTEM_PROMPT_FILE)" "$SYSTEM_PROMPT_FILE"
  echo

  bold_underlined "Prompts"
  printf "  %-28s: %s\n" "$(green system_prompt)" "$(truncate_mid "$(prompt_system)" 20)"
  printf "  %-28s: %s\n" "$(green user_prompt)" "$(truncate_mid "$(prompt_user)" 20)"
  echo

  bold_underlined "Files"
  printf "  %-28s: %s\n" \
    "$(green config file)" \
    "$(if [[ -f "$CONFIG_FILE" ]]; then echo exists; else echo does not exist; fi)"

  printf "  %-28s: %s\n" \
    "$(green system prompt file)" \
    "$(if [[ -f "$SYSTEM_PROMPT_FILE" ]]; then echo exists; else echo does not exist; fi)"

  printf "  %-28s: %s\n" \
    "$(green user prompt file)" \
    "$(if [[ -f "$USER_PROMPT_FILE" ]]; then echo exists; else echo does not exist; fi)"

}

# :command.function
nlc_config_clear_command() {

  # src/commands/config/clear.sh
  printf "rm %s\n" "$(green "$CONFIG_FILE")"
  rm -f "$CONFIG_FILE"
}

# :command.function
nlc_config_edit_command() {

  # src/commands/config/edit.sh
  if [[ ! -s "$CONFIG_FILE" ]]; then
    printf "defaults > %s\n" "$(green "$CONFIG_FILE")"
    config_create_defaults
  fi

  printf "%s %s\n" "$EDITOR" "$(green "$CONFIG_FILE")"
  "$EDITOR" "$CONFIG_FILE"

}

# :command.function
nlc_config_new_command() {

  # src/commands/config/new.sh
  force="${args[--force]}"
  if [[ -f "$CONFIG_FILE" && -z "$force" ]]; then
    printf "config file already exists: %s\n" "$(green "$CONFIG_FILE")"
    printf "run with %s to overwrite\n" "$(magenta --force)"
    return 2
  fi

  printf "defaults > %s\n" "$(green "$CONFIG_FILE")"
  config_create_defaults

}

# :command.function
nlc_prompt_system_command() {

  # src/commands/prompt/system.sh
  if [[ "${args[--clear]}" ]]; then
    printf "rm %s\n" "$(green "$SYSTEM_PROMPT_FILE")"
    rm -f "$SYSTEM_PROMPT_FILE"
  fi

  if [[ "${args[--default]}" ]]; then
    printf "defaults > %s\n" "$(green "$SYSTEM_PROMPT_FILE")"
    prompt_system >"$SYSTEM_PROMPT_FILE"
  fi

  if [[ "${args[--edit]}" ]]; then
    printf "%s %s\n" "$EDITOR" "$(green "$SYSTEM_PROMPT_FILE")"
    "$EDITOR" "$SYSTEM_PROMPT_FILE"
  else
    prompt_system
  fi
}

# :command.function
nlc_prompt_user_command() {

  # src/commands/prompt/user.sh
  if [[ "${args[--clear]}" ]]; then
    printf "rm %s\n" "$(green "$USER_PROMPT_FILE")"
    rm -f "$USER_PROMPT_FILE"
  fi

  if [[ "${args[--edit]}" ]]; then
    printf "%s %s\n" "$EDITOR" "$(green "$USER_PROMPT_FILE")"
    "$EDITOR" "$USER_PROMPT_FILE"
  else
    prompt_user
  fi
}

# :command.parse_requirements
parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        nlc_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export NLC_CONFIG="${NLC_CONFIG:-~/.nlc/config}"

  env_var_names+=("NLC_CONFIG")

  # :command.command_filter
  action=${1:-}

  case $action in

    run)
      action="run"
      shift
      nlc_run_parse_requirements "$@"
      shift $#
      ;;

    config)
      action="config"
      shift
      nlc_config_parse_requirements "$@"
      shift $#
      ;;

    prompt)
      action="prompt"
      shift
      nlc_prompt_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      nlc_usage >&2
      exit 1
      ;;

    *)
      action="run"
      nlc_run_parse_requirements "$@"
      shift $#
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nlc_run_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        nlc_run_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v curl >/dev/null 2>&1; then
    printf "missing dependency: curl\n" >&2
    missing_deps=1
  else
    deps['curl']="$(command -v curl | head -n1)"
  fi

  # :dependency.filter
  if ! command -v jq >/dev/null 2>&1; then
    printf "missing dependency: jq\n" >&2
    missing_deps=1
  else
    deps['jq']="$(command -v jq | head -n1)"
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action="run"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_repeatable
        # :argument.case_repeatable
        escaped="$(printf '%q' "$1")"
        if [[ -z ${args['message']+x} ]]; then
          args['message']="$escaped"
        else
          args['message']="${args['message']} $escaped"

        fi
        shift

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['message']+x} ]]; then
    printf "missing required argument: MESSAGE\nusage: nlc [run] MESSAGE...\n" >&2
    # :command.examples_on_error
    printf "examples:\n" >&2
    printf "  nlc convert input.webm to output.mp4\n" >&2
    printf "  nlc list all docker images older than a month and delete them\n" >&2

    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_api_key_found)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
nlc_config_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        nlc_config_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    show | s)
      action="show"
      shift
      nlc_config_show_parse_requirements "$@"
      shift $#
      ;;

    clear | c)
      action="clear"
      shift
      nlc_config_clear_parse_requirements "$@"
      shift $#
      ;;

    edit | e)
      action="edit"
      shift
      nlc_config_edit_parse_requirements "$@"
      shift $#
      ;;

    new | n)
      action="new"
      shift
      nlc_config_new_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      nlc_config_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nlc_config_show_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        nlc_config_show_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config show"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nlc_config_clear_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        nlc_config_clear_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config clear"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nlc_config_edit_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        nlc_config_edit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config edit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nlc_config_new_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        nlc_config_new_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config new"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nlc_prompt_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        nlc_prompt_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    system | s)
      action="system"
      shift
      nlc_prompt_system_parse_requirements "$@"
      shift $#
      ;;

    user | u)
      action="user"
      shift
      nlc_prompt_user_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      nlc_prompt_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nlc_prompt_system_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        nlc_prompt_system_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="prompt system"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --default | -d)

        # :flag.case_no_arg
        args['--default']=1
        shift
        ;;

      # :flag.case
      --clear | -c)

        # :flag.case_no_arg
        args['--clear']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nlc_prompt_user_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        nlc_prompt_user_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="prompt user"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --clear | -c)

        # :flag.case_no_arg
        args['--clear']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.2.2"
  set -eo pipefail

  # :command.environment_variables_default
  export NLC_CONFIG="${NLC_CONFIG:-~/.nlc/config}"

  # src/initialize.sh
  declare -g PROVIDER
  declare -g MODEL
  declare -g API_KEY
  declare -g API_BASE
  declare -g SYSTEM_PROMPT_FILE
  declare -g USER_PROMPT_FILE
  declare -g EDITOR
  declare -g CONFIG_FILE

  CONFIG_FILE=${NLC_CONFIG/#\~/$HOME}

  PROVIDER="$(config_get ai.provider openai)"

  case "$PROVIDER" in
    groq)
      default_base="https://api.groq.com/openai/v1"
      default_key="$GROQ_API_KEY"
      default_model="llama-3.3-70b-versatile"
      ;;
    *)
      default_base="https://api.openai.com/v1"
      default_key="$OPENAI_API_KEY"
      default_model=gpt-3.5-turbo
      ;;
  esac

  MODEL="$(config_get ai.model "$default_model")"
  API_KEY="$(config_get ai.api_key "$default_key")"
  API_BASE="$(config_get ai.api_base "$default_base")"

  SYSTEM_PROMPT_FILE="$(config_get prompt.system "$HOME/.nlc/system_prompt")"
  USER_PROMPT_FILE="$(config_get prompt.user "$HOME/.nlc/user_prompt")"

  EDITOR="${EDITOR:-vi}"

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "run") nlc_run_command ;;
    "config") nlc_config_command ;;
    "config show") nlc_config_show_command ;;
    "config clear") nlc_config_clear_command ;;
    "config edit") nlc_config_edit_command ;;
    "config new") nlc_config_new_command ;;
    "prompt") nlc_prompt_command ;;
    "prompt system") nlc_prompt_system_command ;;
    "prompt user") nlc_prompt_user_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
